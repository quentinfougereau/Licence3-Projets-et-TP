<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>

  <script src=
  "https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
  <script src="../htex-ress/clipboard.min.js"></script>
  <link rel="stylesheet" type="text/css" media="screen" href=
  "../htex-ress/basic-screen.css" />
  <link rel="stylesheet" type="text/css" media="printer" href=
  "../htex-ress/basic-printer.css" />
  <meta http-equiv="Content-Type" content=
  "text/html; charset=us-ascii" />
  <title>TP1&#160;: Simulation d'une C.P.U. et d'un
  syst&#232;me</title>
  <link rel="stylesheet" type="text/css" href=
  "../blue40.screen.css" media="screen" />
  <link rel="stylesheet" type="text/css" href="../blue40.print.css"
  media="print" />
</head>
<body>
  <div id="allPage">
    <div id="header">
      <span class="header-item" id="header-accueil"><a href=
      "../index.html">Accueil</a></span><span class="header-item"
      id="m26-java"><a href="../jee/index.html">Architecture
      JEE</a></span><span class="header-item"><a href=
      "../arch-app/index.html">Architecture des
      applications</a></span><span class="header-item" id=
      "m27-xml"><a href=
      "../xml/index.html">XML</a></span><span class="header-item"
      id="info13"><a href="../systeme/index.html">Syst&#232;me
      d'exploitation</a></span><span class="header-item" id=
      "header-docs"><a href=
      "../docs/index.html">Docs</a></span><span class="header-item"
      id="xdosicalu"><a href=
      "../dosicalu/index.html">DOSICALU</a></span><span class=
      "header-item" id="header-dil"><a href=
      "http://dii.univ-mrs.fr">D&#233;partement
      d'informatique</a></span><a href="../chercher.html" id=
      "header-search" name="header-search"></a>
    </div>
    <div id="leftFrame">
      <div id="menu">
        <a class="menu1 menu-normal" href=
        "index.html"><span>Accueil</span></a><a class=
        "menu1 menu-normal" href="#"><span>Sujets de
        TPs&#160;:</span></a><a class="menu2 menu-active" href=
        "tp01-simul1.html"><span>1. CPU et
        multi-t&#226;ches</span></a><a class="menu2 menu-normal"
        href="tp02-simul2.html"><span>2.
        Entr&#233;es/sorties</span></a><a class="menu2 menu-normal"
        href="tp03-thread.html"><span>3. Threads &amp;
        s&#233;maphores</span></a><a class="menu2 menu-normal"
        href="tp04-philo.html"><span>4. Condition de
        synchronisation</span></a><a class="menu2 menu-normal"
        href="tp05-mem.html"><span>5. Gestion
        m&#233;moire</span></a><a class="menu2 menu-normal" href=
        "tp06-ipc.html"><span>6. Les IPC UNIX</span></a><a class=
        "menu2 menu-normal" href="tp07-sgf.html"><span>7. Un mini
        SGF (1/2)</span></a><a class="menu2 menu-normal" href=
        "tp08-sgf.html"><span>8. Un mini SGF
        (2/2)</span></a><a class="menu1 menu-normal" href=
        "#"><span>Liens&#160;:</span></a><a class=
        "menu2 menu-normal" href=
        "https://formations.univ-amu.fr/ME3SIN-PRSIN3AA.html"><span>&gt;&#160;Licence
        d'Info.</span></a><a class="menu2 menu-normal" href=
        "http://ametice.univ-amu.fr/course/view.php?id=30983"><span>&gt;&#160;AMETICE</span></a>
      </div>
      <div id="printable">
        <a href="tp01-simul1.pdf">Version PDF</a>
      </div>
    </div>
    <div id="content">
      <h1 id="idhtex-h1-1">TP1&#160;: Simulation d'une C.P.U. et
      d'un syst&#232;me</h1>
      <div id="table-of-contents">
        <div class="table-of-contents-title">
          &#160;Sommaire
        </div>
        <div class="table-of-contents-level1">
          &gt;&#160;<a href="#idhtex-h2-1">Pr&#233;sentation de la
          machine</a>
        </div>
        <div class="table-of-contents-level2">
          &gt;&#160;<a href="#idhtex-h3-1">M&#233;moire
          centrale</a>
        </div>
        <div class="table-of-contents-level2">
          &gt;&#160;<a href="#idhtex-h3-2">Instructions de la
          C.P.U.</a>
        </div>
        <div class="table-of-contents-level2">
          &gt;&#160;<a href="#idhtex-h3-3">Structure de la
          C.P.U.</a>
        </div>
        <div class="table-of-contents-level2">
          &gt;&#160;<a href="#idhtex-h3-4">Adressage logique et
          physique</a>
        </div>
        <div class="table-of-contents-level2">
          &gt;&#160;<a href="#idhtex-h3-5">Simulation de la
          machine</a>
        </div>
        <div class="table-of-contents-level1">
          &gt;&#160;<a href="#idhtex-h2-2">Nouvelles fonctions
          &#224; r&#233;aliser</a>
        </div>
        <div class="table-of-contents-level2">
          &gt;&#160;<a href="#idhtex-h3-6">Tracer les
          interruptions</a>
        </div>
        <div class="table-of-contents-level2">
          &gt;&#160;<a href="#idhtex-h3-7">Am&#233;liorer le
          programme</a>
        </div>
        <div class="table-of-contents-level2">
          &gt;&#160;<a href="#idhtex-h3-8">Appels au
          syst&#232;me</a>
        </div>
        <div class="table-of-contents-level1">
          &gt;&#160;<a href="#idhtex-h2-3">Introduction du
          multi-t&#226;ches</a>
        </div>
        <div class="table-of-contents-level2">
          &gt;&#160;<a href="#idhtex-h3-9">Codage des processus</a>
        </div>
        <div class="table-of-contents-level2">
          &gt;&#160;<a href="#idhtex-h3-10">Un ordonnanceur
          simplifi&#233;</a>
        </div>
        <div class="table-of-contents-level1">
          &gt;&#160;<a href="#sysc">Les appels syst&#232;mes</a>
        </div>
        <div class="table-of-contents-level2">
          &gt;&#160;<a href="#idhtex-h3-11">La bonne version de
          EXIT</a>
        </div>
        <div class="table-of-contents-level2">
          &gt;&#160;<a href="#idhtex-h3-12">Cr&#233;ation de
          thread</a>
        </div>
        <div class="table-of-contents-level2">
          &gt;&#160;<a href="#idhtex-h3-13">Appel syst&#232;me de
          cr&#233;ation de thread</a>
        </div>
        <div class="table-of-contents-level2">
          &gt;&#160;<a href="#idhtex-h3-14">M&#233;moire
          partag&#233;e</a>
        </div>
      </div>
      <p><span class="htex-DANGER">Les TP&#160;1 et 2 sont &#224;
      rendre au plus tard avant le TP&#160;3.</span></p>
      <p>Les modalit&#233;s seront pr&#233;cis&#233;es lors des
      s&#233;ances suivantes.</p>
      <p><span class="htex-DANGER">13/11/2018: Attention, le TP2
      n'est plus rendre.</span></p>
      <h2 id="idhtex-h2-1">Pr&#233;sentation de la machine</h2>
      <p>Pour suivre ce TP vous devez <a href="simul.zip" shape=
      "rect">r&#233;cup&#233;rer le prototype du simulateur</a> qui
      est mis &#224; votre disposition. Ce prototype a la structure
      suivante&#160;:</p>
      <ul>
        <li><span class="htex-ttt">cpu.c</span> et <span class=
        "htex-ttt">cpu.h</span>&#160;: d&#233;finition de la CPU et
        de la m&#233;moire</li>
        <li><span class="htex-ttt">systeme.c</span> et <span class=
        "htex-ttt">systeme.h</span>&#160;: d&#233;finition du
        syst&#232;me</li>
        <li><span class="htex-ttt">asm.c</span>&#160;: un
        mini-assembleur</li>
        <li><span class="htex-ttt">simul.c</span>&#160;: fonction
        principale</li>
      </ul>
      <h3 id="idhtex-h3-1">M&#233;moire centrale</h3>
      <p>La m&#233;moire centrale de notre machine est
      compos&#233;e de mots. Un mot m&#233;moire est un entier de
      32&#160;bits (la taille des entiers sur une architecture PC
      classique). La m&#233;moire contient quelques dizaines de
      mots simul&#233;s par un simple tableau. Les adresses
      physiques sont contigu&#235;s et varient de z&#233;ro &#224;
      127.</p>
      <div>
        <div class="htex-code htex-copy prettyprint lang-c">
          <div class="htex-copy-button">
            <button class="htex-copy-button" data-clipboard-target=
            "#idm104" type="submit"><img width="16" alt="" src=
            "../htex-ress/clippy.svg" /></button>
          </div>
          <pre xml:space="preserve" id="idm104" class=
          "htex-code htex-copy prettyprint lang-c">
typedef int WORD;  /* un mot est un entier 32 bits  */

WORD mem[128];     /* memoire                       */

/* fonctions de lecture / &#233;criture */
WORD read_mem(int physical_address);
void write_mem(int physical_address, WORD value);
</pre>
        </div>
      </div>
      <h3 id="idhtex-h3-2">Instructions de la C.P.U.</h3>
      <p>Notre C.P.U. ex&#233;cute des instructions &#224; taille
      fixe (un mot de 32&#160;bits). Une instruction est
      compos&#233;e d'un code op&#233;ration, de deux num&#233;ros
      de registre et d'un argument. Vous pouvez voir les
      d&#233;tails ci-dessous&#160;:</p>
      <div>
        <div class="htex-code htex-copy prettyprint lang-c">
          <div class="htex-copy-button">
            <button class="htex-copy-button" data-clipboard-target=
            "#idm112" type="submit"><img width="16" alt="" src=
            "../htex-ress/clippy.svg" /></button>
          </div><span>D&#233;finition d'une instruction</span>
          <pre xml:space="preserve" id="idm112" class=
          "htex-code htex-copy prettyprint lang-c">
typedef struct {
    unsigned OP: 10;  /* code operation (10 bits)  */
    unsigned i:   3;  /* nu 1er registre (3 bits)  */
    unsigned j:   3;  /* nu 2eme registre (3 bits) */
    short    ARG;     /* argument (16 bits)        */
} INST;
</pre>
        </div>
      </div>
      <p>Une instruction va ressembler &#224; ceci&#160;:
      <span class=
      "htex-ttt">ADD&#160;R1,&#160;R2,&#160;1000</span>. Elle va
      effectuer l'affectation <span class=
      "htex-ttt">R1=R1+R2+1000</span>. Afin de ne pas rendre la
      cr&#233;ation d'un programme trop p&#233;nible, des fonctions
      sont fournies pour implanter des instructions en m&#233;moire
      (fichier <span class="htex-ttt">asm.h</span>)&#160;:</p>
      <div>
        <div class="htex-code htex-copy prettyprint lang-c">
          <div class="htex-copy-button">
            <button class="htex-copy-button" data-clipboard-target=
            "#idm120" type="submit"><img width="16" alt="" src=
            "../htex-ress/clippy.svg" /></button>
          </div>
          <pre xml:space="preserve" id="idm120" class=
          "htex-code htex-copy prettyprint lang-c">
enum {R0, R1, R2, R3, R4, R5, R6, R7 };

void begin(int begin_adr); /* d&#233;but du programme */
void end();                /* fin du programme   */

void set(int ri, int arg);           // Ri = arg
void add(int ri, int rj, int arg);   // Ri = Ri + Rj + arg
void sub(int ri, int rj, int arg);   // Ri = Ri - Rj - arg
void load(int ri, int rj, int arg);  // Ri = mem[ Rj + arg ]
void store(int ri, int rj, int arg); // mem[ Rj + arg ] = Ri
void cmp(int ri, int rj);            // AC = (Ri - Rj)
void nop();                          // ne rien faire
void label(int label);               // fixer une &#233;tiquette
void if_gt(int label);               // si (AC &gt; 0) aller &#224;
void jump(int label);                // aller &#224; 
void sysc(int ri, int rj, int arg);  // appel du syst&#232;me
void halt();                         // arr&#234;ter la machine
</pre>
        </div>
      </div>
      <p>La cr&#233;ation d'un programme devient une s&#233;quence
      d'appels &#224; ces fonctions. En voila un exemple (voir
      <span class="htex-ttt">system.c</span>)&#160;:</p>
      <div>
        <div class="htex-code htex-copy prettyprint lang-c">
          <div class="htex-copy-button">
            <button class="htex-copy-button" data-clipboard-target=
            "#idm126" type="submit"><img width="16" alt="" src=
            "../htex-ress/clippy.svg" /></button>
          </div>
          <pre xml:space="preserve" id="idm126" class=
          "htex-code htex-copy prettyprint lang-c">
begin(20);
        set(R2, 1000);
    label(10);
        add(R1, R2, 1000);
        nop();
        jump(10);
end();
</pre>
        </div>
      </div>
      <h3 id="idhtex-h3-3">Structure de la C.P.U.</h3>
      <p>Le mot d'&#233;tat du processeur est d&#233;fini comme
      suit</p>
      <div>
        <div class="htex-code htex-copy prettyprint lang-c">
          <div class="htex-copy-button">
            <button class="htex-copy-button" data-clipboard-target=
            "#idm133" type="submit"><img width="16" alt="" src=
            "../htex-ress/clippy.svg" /></button>
          </div>
          <pre xml:space="preserve" id="idm133" class=
          "htex-code htex-copy prettyprint lang-c">
typedef struct PSW { /* Processor Status Word */
    WORD PC;         /* Program Counter */
    WORD SB;         /* Segment Base */
    WORD SS;         /* Segment Size */
    WORD IN;         /* Interrupt number */
    WORD DR[8];      /* Data Registers */
    WORD AC;         /* Accumulateur */
    INST RI;         /* Registre instruction */
} PSW;
</pre>
        </div>
      </div>
      <p>D&#233;finition des registres&#160;:</p>
      <ul>
        <li><span class="htex-ttt">PC</span>&#160;: Le <span class=
        "htex-IMP">Program Counter</span> (compteur ordinal) est un
        pointeur sur la prochaine instruction &#224; ex&#233;cuter
        (en fait un entier).</li>
        <li><span class="htex-ttt">SB</span> et <span class=
        "htex-ttt">SS</span>&#160;: voir section suivante.</li>
        <li><span class="htex-ttt">IN</span>&#160;: En cas
        d'interruption, la CPU range dans ce registre la cause de
        cette interruption. Cette information peut &#234;tre
        exploit&#233;e par le syst&#232;me d'exploitation.</li>
        <li><span class="htex-ttt">DR[i]</span>&#160;: La C.P.U.
        dispose de huit registres g&#233;n&#233;raux pouvant
        contenir chacun un entier sign&#233; de 32&#160;bits.</li>
        <li><span class="htex-ttt">AC</span>&#160;: Le registre
        accumulateur est un relais entre d'une part les
        instructions de test et d'autre part les instructions de
        branchement conditionel. Le registre <span class=
        "htex-ttt">AC</span> est &#233;galement affect&#233; par
        les instructions qui modifient le contenu d'un registre
        (chargement, calcul, incr&#233;mentation, ...).</li>
      </ul>
      <h3 id="idhtex-h3-4">Adressage logique et physique</h3>
      <p>Durant l'ex&#233;cution, la CPU adresse la m&#233;moire en
      utilisant des <span class="htex-IMP">adresses logiques</span>
      c'est &#224; dire des entiers compris entre 0 et la taille de
      la zone m&#233;moire allou&#233;e &#224; ce processus
      (<span class="htex-IMP">Segment</span>). Le d&#233;but de
      cette zone m&#233;moire est point&#233; par le registre
      <span class="htex-ttt">SB</span> (<span class=
      "htex-IMP">Segment Base</span>) tandis que le registre
      <span class="htex-ttt">SS</span> en donne la taille
      (<span class="htex-IMP">Segment Size</span>).</p>
      <blockquote>
        <div>
          <pre xml:space="preserve" id="idm168">
       &lt;--------------  SS  --------------&gt;
    ---+---+---+------------------+---+---+---
...    |   |   |       ....       |   |   |    ...
    ---+---+---+------------------+---+---+---
         ^
         SB
</pre>
        </div>
      </blockquote>
      <p>pour chaque adresse logique <span class=
      "htex-ttt">al</span> la CPU calcule l'adresse physique
      <span class="htex-ttt">ap</span> en appliquant l'algorithme
      suivant (voir <span class="htex-ttt">cpu.c</span>)&#160;:</p>
      <div>
        <div class="htex-code">
          <pre xml:space="preserve" id="idm176" class="htex-code">
lire(al) :
  | si (al &lt; 0) ou (al &gt;= SS) &lt;erreur adressage&gt;
  | ap = (SB + al)
  | renvoyer mem[ap]
</pre>
        </div>
      </div>
      <h3 id="idhtex-h3-5">Simulation de la machine</h3>
      <p>Nous avons vu en cours que la CPU passe son temps &#224;
      alterner des cycles ou elle ex&#233;cute du code utilisateur
      et des cycles ou elle ex&#233;cute du code syst&#232;me. Elle
      passe du code utilisateur au code syst&#232;me par une
      interruption et du code syst&#232;me au code utilisateur par
      un chargement du mot d'&#233;tat processeur (ou <span class=
      "htex-IMP">processor Status Word</span>). On peut donc
      simuler ce comportement par le code ci-dessous&#160;:</p>
      <div>
        <div class="htex-code htex-copy prettyprint lang-c">
          <div class="htex-copy-button">
            <button class="htex-copy-button" data-clipboard-target=
            "#idm184" type="submit"><img width="16" alt="" src=
            "../htex-ress/clippy.svg" /></button>
          </div>
          <pre xml:space="preserve" id="idm184" class=
          "htex-code htex-copy prettyprint lang-c">
int main(void) {
    init_cpu();
    for(PSW mep = system_init();;) {
        mep = cpu(mep);
        mep = process_interrupt(mep);
    }
    return (EXIT_SUCCESS);
}
</pre>
        </div>
      </div>
      <p>La fonction <span class="htex-ttt">cpu()</span> simule
      l'ex&#233;cution du code utilisateur jusqu'&#224;
      l'apparition d'une interruption. La fonction <span class=
      "htex-ttt">process_interrupt()</span> reprends la main,
      traite l'interruption et redonne la main au code
      utilisateur.</p>
      <h2 id="idhtex-h2-2">Nouvelles fonctions &#224;
      r&#233;aliser</h2>
      <h3 id="idhtex-h3-6">Tracer les interruptions</h3>
      <ol type="1">
        <li>Pour l'instant le simulateur boucle sans rien afficher.
        Faites en sorte que le syst&#232;me indique les
        num&#233;ros d'interruption re&#231;us (fonction
        <span class="htex-ttt">process_interrupt</span> de
        <span class="htex-ttt">system.c</span> &#224;
        modifier).</li>
        <li>Faites en sorte que les interruptions d'erreur
        (instruction inconnue et erreur d'adressage) provoque
        l'arr&#234;t du simulateur. Modifiez le programme
        ex&#233;cut&#233; pour faire appara&#238;tre ces deux
        interruptions.</li>
        <li>Modifiez le code du syst&#232;me pour que
        l'interruption <span class="htex-ttt">TRACE</span> provoque
        l'affichage des registres (appel de <span class=
        "htex-ttt">dump_cpu</span>).</li>
      </ol>
      <h3 id="idhtex-h3-7">Am&#233;liorer le programme</h3>
      <p>Nous allons maintenant utiliser de nouvelles instructions
      de la C.P.U. afin d'ex&#233;cuter la simple boucle
      ci-dessous&#160;:</p>
      <div>
        <div class="htex-code htex-copy prettyprint lang-c">
          <div class="htex-copy-button">
            <button class="htex-copy-button" data-clipboard-target=
            "#idm211" type="submit"><img width="16" alt="" src=
            "../htex-ress/clippy.svg" /></button>
          </div>
          <pre xml:space="preserve" id="idm211" class=
          "htex-code htex-copy prettyprint lang-c">
begin(20);
        set(R1, 0);      /* R1 = 0              */
        set(R2, 1000);   /* R2 = 1000           */
        set(R3, 5);      /* R3 = 5              */
    label(10);           /* set label 10        */
        cmp(R1, R2);     /* AC = (R1 - R2)      */
        if_gt(20);       /* if (AC &gt; 0) go 20   */
        nop();           /* no operation        */
        nop();           /* no operation        */
        add(R1, R3, 0);  /* R1 += (R3 + 0)      */
        jump(10);        /* go 10               */
    label(20);           /* set label 20        */
        halt();          /* poweroff            */
end();
</pre>
        </div>
      </div>
      <h3 id="idhtex-h3-8">Appels au syst&#232;me</h3>
      <p>Pour l'instant les affichages de notre simulateur sont
      r&#233;alis&#233;s par les traces du <span class=
      "htex-IMP">PSW</span> faites par le syst&#232;me. Il est
      temps maintenant d'utiliser une nouvelle instruction, que
      nous appellerons <span class="htex-ttt">SYSC</span>, dont le
      but est de g&#233;n&#233;rer une interruption afin de donner
      la main au syst&#232;me. La partie argument de cette
      instruction indiquera au syst&#232;me l'action voulue et les
      registres indiqueront les &#233;ventuels param&#232;tres de
      cette action.</p>
      <p><span class="htex-IMP">Pr&#233;paration</span>&#160;:</p>
      <ul>
        <li>Consultez les num&#233;ros d'interruption pr&#233;vus
        and <span class="htex-ttt">cpu.h</span>.</li>
        <li>Ajoutez au syst&#232;me le traitement de l'interruption
        <span class="htex-ttt">INT_SYSC</span> (affichage).</li>
        <li>Testez le bon fonctionnement en pla&#231;ant une
        instruction <span class="htex-ttt">SYSC</span> au coeur de
        la boucle.</li>
      </ul>
      <p><span class="htex-IMP">Utilisation</span>&#160;:</p>
      <ol type="1">
        <li>Commencez par implanter l'appel syst&#232;me
        <span class="htex-ttt">SYSC_EXIT</span> qui provoque
        l'arr&#234;t du processus demandeur et donc du syst&#232;me
        puisque nous avons, pour l'instant, un seul processus
        (pr&#233;voir une fonction <span class=
        "htex-ttt">sysc_exit()</span>).</li>
        <li>Continuez avec l'appel <span class=
        "htex-ttt">SYSC_PUTI</span> qui affiche l'entier
        stock&#233; dans le premier registre de l'instruction
        <span class="htex-ttt">SYSC</span>. Vous pouvez maintenant
        placer cette instruction au coeur de la boucle et voir le
        d&#233;roulement de la boucle.</li>
        <li>Utilisez l'instruction de lecture m&#233;moire
        (<span class="htex-ttt">LOAD</span>) dans la boucle pour
        provoquer une erreur de d&#233;bordement de l'acc&#232;s
        m&#233;moire. v&#233;rifiez que le r&#233;sultat obtenu est
        conforme au param&#232;tre utilis&#233; dans
        l'initialisation du syst&#232;me (registre <span class=
        "htex-ttt">SS</span>).</li>
      </ol>
      <h2 id="idhtex-h2-3">Introduction du multi-t&#226;ches</h2>
      <p>Le but de cette section est double&#160;: d'une part,
      ajouter des fonctions multi-t&#226;ches en temps partag&#233;
      &#224; notre mini syst&#232;me et d'autre part, utiliser ces
      nouvelles fonctions pour endormir les processus pendant un
      certain temps</p>
      <h3 id="idhtex-h3-9">Codage des processus</h3>
      <p>Commencez par ajouter au simulateur les structures de
      donn&#233;es ci-dessous. Elles permettent de repr&#233;senter
      un ensemble de processus et leur mot d'&#233;tat
      processeur.</p>
      <div>
        <div class="htex-code htex-copy prettyprint lang-c">
          <div class="htex-copy-button">
            <button class="htex-copy-button" data-clipboard-target=
            "#idm257" type="submit"><img width="16" alt="" src=
            "../htex-ress/clippy.svg" /></button>
          </div>
          <pre xml:space="preserve" id="idm257" class=
          "htex-code htex-copy prettyprint lang-c">
#define MAX_PROCESS  (20)   /* nb maximum de processus  */

#define EMPTY         (0)   /* processus non-pr&#234;t       */
#define READY         (1)   /* processus pr&#234;t           */

struct {
    PSW  cpu;               /* mot d'&#233;tat du processeur */
    int  state;             /* &#233;tat du processus        */
    }
    process[MAX_PROCESS];   /* table des processus      */

int current_process = -1;   /* nu du processus courant  */
</pre>
        </div>
      </div>
      <p>Faites en sorte qu'au d&#233;marrage du syst&#232;me, le
      syst&#232;me pr&#233;pare la premi&#232;re case du tableau
      des processus. Il y a pour l'instant un seul processus.</p>
      <h3 id="idhtex-h3-10">Un ordonnanceur simplifi&#233;</h3>
      <p>A chaque interruption <span class="htex-ttt">TRACE</span>,
      le syst&#232;me va maintenant sauvegarder le PSW dans la case
      correspondante du tableau des processus et chercher un
      nouveau processus pr&#234;t pour lui redonner la C.P.U. (voir
      recherche ci-dessous).</p>
      <div>
        <div class="htex-code htex-copy prettyprint lang-c">
          <div class="htex-copy-button">
            <button class="htex-copy-button" data-clipboard-target=
            "#idm268" type="submit"><img width="16" alt="" src=
            "../htex-ress/clippy.svg" /></button>
          </div><span>Algorithme de l'ordonnanceur</span>
          <pre xml:space="preserve" id="idm268" class=
          "htex-code htex-copy prettyprint lang-c">
/* sauvegarder le processus courant si il existe */
do {
    current_process = (current_process + 1) % MAX_PROCESS;
} while (process[current_process].state != READY);
/* relancer ce processus */
</pre>
        </div>
      </div>
      <p>Utilisez de pr&#233;f&#233;rence la signature <span class=
      "htex-ttt">PSW&#160;scheduler(PSW m)</span> pour la fonction
      qui code l'ordonnanceur.</p>
      <p>A ce stade, le simulateur doit fonctionner correctement.
      &#201;tant donn&#233; qu'il n'y a qu'un seul processus, il
      est syst&#233;matiquement sauvegard&#233; puis choisi pour
      &#234;tre ex&#233;cut&#233;.</p>
      <p>Pour tester votre ordonnanceur, vous pouvez maintenant
      cr&#233;er directement deux processus au d&#233;marrage du
      syst&#232;me (prenez l'exemple de boucle de la section
      pr&#233;c&#233;dente). Utilisez le m&#234;me segment pour ces
      deux processus. Ce sont plus des <span class=
      "htex-IMP">threads</span> que des <span class=
      "htex-IMP">processus</span> puisqu'ils partagent leur code et
      leur donn&#233;es. Les sorties des deux processus devraient
      se m&#233;langer pour illustrer le multi-t&#226;ches
      simul&#233;.</p>
      <h2 id="sysc">Les appels syst&#232;mes</h2>
      <h3 id="idhtex-h3-11">La bonne version de EXIT</h3>
      <p>Faites en sorte que l'appel syst&#232;me <span class=
      "htex-ttt">SYSC_EXIT</span> provoque l'arr&#234;t du
      syst&#232;me quand il n'y a plus de processus (v&#233;rifiez
      notamment que les deux processus arrivent &#224; leur
      terme).</p>
      <h3 id="idhtex-h3-12">Cr&#233;ation de thread</h3>
      <p>Commencez par r&#233;aliser une fonction de cr&#233;ation
      d'un thread fils par duplication du thread courant (le
      param&#232;tre)&#160;:</p>
      <div>
        <div class="htex-code htex-copy prettyprint lang-c">
          <div class="htex-copy-button">
            <button class="htex-copy-button" data-clipboard-target=
            "#idm291" type="submit"><img width="16" alt="" src=
            "../htex-ress/clippy.svg" /></button>
          </div>
          <pre xml:space="preserve" id="idm291" class=
          "htex-code htex-copy prettyprint lang-c">
int new_thread(PSW cpu) { ... }
</pre>
        </div>
      </div>
      <p>Chez le fils l'accumulateur (<span class=
      "htex-ttt">AC</span>) est forc&#233; &#224; z&#233;ro.</p>
      <h3 id="idhtex-h3-13">Appel syst&#232;me de cr&#233;ation de
      thread</h3>
      <p>Ajoutez ensuite un nouvel appel syst&#232;me (<span class=
      "htex-ttt">SYSC&#160;Ri,Rj,SYSC_NEW_THREAD</span>) qui
      duplique le thread courant pour en cr&#233;er un nouveau.
      Chez le p&#232;re (l'appelant), le syst&#232;me renvoie le
      num&#233;ro du thread fils dans le registre <span class=
      "htex-ttt">Ri</span> (et <span class="htex-ttt">AC</span>).
      Le p&#232;re et le fils continuent leur ex&#233;cution &#224;
      la premi&#232;re instruction qui suit l'appel au
      syst&#232;me.</p>
      <p>Voici un exemple d'utilisation&#160;:</p>
      <div>
        <div class="htex-code htex-copy prettyprint lang-c">
          <div class="htex-copy-button">
            <button class="htex-copy-button" data-clipboard-target=
            "#idm306" type="submit"><img width="16" alt="" src=
            "../htex-ress/clippy.svg" /></button>
          </div>
          <pre xml:space="preserve" id="idm306" class=
          "htex-code htex-copy prettyprint lang-c">
[Exemple de cr&#233;ation d'un thread]
begin(20);
    /*** cr&#233;er un thread ***/
    sysc(R1, R1, SYSC_NEW_THREAD);  /* cr&#233;er un thread  */
    if_gt(10);                      /* le p&#232;re va en 10 */

    /*** code du fils ***/
    set(R3, 1000);                  /* R3 = 1000    */
    sysc(R3, 0, SYSC_PUTI);         /* afficher R3  */
    nop();
    nop();

    /*** code du p&#232;re ***/
    label(10);                     /* set label 10   */
    set(R3, 2000);                 /* R3 = 1000      */
    sysc(R3, 0, SYSC_PUTI);        /* afficher R3    */
    sysc(0, 0, SYSC_EXIT);         /* fin du thread  */
end();
</pre>
        </div>
      </div>
      <h3 id="idhtex-h3-14">M&#233;moire partag&#233;e</h3>
      <p>Programmez un exemple dans lequel le fils incr&#233;mente
      le contenu d'une case m&#233;moire et le p&#232;re l'affiche
      sans la modifier. Vous aurez besoin de l'instruction
      <span class="htex-ttt">STORE</span>.</p>
    </div>
  </div>
  <script src="../htex-ress/init.js"></script>
</body>
</html>
