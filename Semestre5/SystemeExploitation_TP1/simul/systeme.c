
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "cpu.h"
#include "asm.h"
#include "systeme.h"

#define MAX_PROCESS  (20)   /* nb maximum de processus  */
#define EMPTY         (0)   /* processus non-prêt       */
#define READY         (1)   /* processus prêt           */

struct {
    PSW  cpu;               /* mot d'état du processeur */
    int  state;             /* état du processus        */
} process[MAX_PROCESS];   /* table des processus      */

int current_process = -1;   /* nu du processus courant  */

PSW scheduler(PSW m) {
  /* sauvegarder le processus courant si il existe */
  int old_process = current_process;
  /*************************************************/
  do {
      current_process = (current_process + 1) % MAX_PROCESS;
  } while (process[current_process].state != READY);
  /* relancer ce processus */
  process[current_process].cpu = process[old_process].cpu;
  process[current_process].cpu.AC = 0;
  process[current_process].state = READY;
  /*************************/
  return m;
}

void sysc_exit(PSW m) {
  switch(m.RI.ARG) {
    case SYSC_EXIT:
      printf("%s\n", "SYSC_EXIT");
      for (int i = 0; i < 20; i++) {
          if (process[i].state == READY)
              process[i].state = EMPTY;
      }
      exit(0);
      break;
    case SYSC_PUTI:
      printf("%s\n", "SYSC_PUTI");
      printf("%d\n", m.DR[m.RI.i]);
      break;
    case SYSC_NEW_THREAD:
      printf("%s\n", "SYSC_NEW_THREAD");
      scheduler(m);
      break;
  }
}

/**********************************************************
** Démarrage du système (création d'un programme)
***********************************************************/

PSW system_init(void) {
    PSW cpu;

    printf("Booting\n");
    /*** création d'un programme ***/

    process[0].state = READY;
    process[0].cpu = cpu;
    current_process = 0;

    begin(20);
        /*
            set(R2, 1000);
        label(10);
            add(R1, R2, 1000);
            nop();
            set(R3, 0);
            load(R3, R3, 29); //OK
            set(R3, 0);
            load(R3, R3, 31); //Violation mémoire (INT_SEGV)
            sysc(R2, R1, SYSC_PUTI);
            sysc(R2, R2, SYSC_EXIT);
            halt();
            jump(10);
        */

        /*
        label(10);          //set label 10
          cmp(R1, R2);      //AC = (R1 - R2)
          if_gt(20);        //if (AC > 0) go 20
          nop();            //no operation
          nop();            //no operation
          add(R1, R3, 0);   //R1 += (R3 + 0)
          set(R3, 0);
          load(R3, R3, 29); //OK
          //set(R3, 0);
          //load(R3, R3, 31); //Violation mémoire (INT_SEGV)
          sysc(R2, R1, SYSC_PUTI);
          sysc(R2, R2, SYSC_EXIT);
          jump(10);         //go 10
        label(20);          // set label 20
          halt();           // poweroff
          */

          begin(20);
              /*** créer un thread ***/
              sysc(R1, R1, SYSC_NEW_THREAD);  /* créer un thread  */
              set(R2, 0);
              if_gt(10);                      /* le père va en 10 */

              /*** code du fils ***/
              set(R1, 5);
              set(R3, 1000);                  /* R3 = 1000    */
              sysc(R3, 0, SYSC_PUTI);         /* afficher R3  */
              store(R3, R1, 10);
              nop();
              nop();

              /*** code du père ***/
              label(10);                     /* set label 10   */
              set(R3, 2000);                 /* R3 = 1000      */
              load(R2, R1, 10);
              sysc(R2, 0, SYSC_PUTI);         /* afficher R2  */
              sysc(R3, 0, SYSC_PUTI);        /* afficher R3    */
              sysc(0, 0, SYSC_EXIT);         /* fin du thread  */
          end();

    end();

    /*** valeur initiale du PSW ***/
    memset (&cpu, 0, sizeof(cpu));
    cpu.PC = 0;
    cpu.SB = 20;
    cpu.SS = 30;

    return cpu;
}


/**********************************************************
** Traitement des interruptions par le système (mode système)
***********************************************************/

PSW process_interrupt(PSW m) {
    // dump_cpu(m);
    switch (m.IN) {
        case INT_SEGV:
            printf("%d\n", INT_SEGV);
            exit(0);
            break;
        case INT_TRACE:
            printf("%d\n", INT_TRACE);
            dump_cpu(m);
            return scheduler(m);
            break;
        case INT_INST:
            printf("%d\n", INT_INST);
            printf("%s\n", "Instruction inconnue");
            exit(0);
            break;
        case INT_SYSC:
            printf("%d\n", INT_SYSC);
            printf("%s\n", "INT_SYSC");
            sysc_exit(m);
            break;
        case INT_KEYBOARD:
            printf("%d\n", INT_KEYBOARD);
            break;
        default:
            break;
    }
    return m;
}
